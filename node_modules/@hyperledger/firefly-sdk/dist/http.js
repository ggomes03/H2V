"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapConfig = void 0;
const axios_1 = require("axios");
const interfaces_1 = require("./interfaces");
function isSuccess(status) {
    return status >= 200 && status < 300;
}
function mapConfig(options, params) {
    const config = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.requestConfig), { params });
    if (options !== undefined) {
        if ('confirm' in options) {
            config.params = Object.assign(Object.assign({}, config.params), { confirm: options.confirm });
        }
        if ('publish' in options) {
            config.params = Object.assign(Object.assign({}, config.params), { publish: options.publish });
        }
        if ('fetchstatus' in options) {
            config.params = Object.assign(Object.assign({}, config.params), { fetchstatus: options.fetchstatus });
        }
    }
    return config;
}
exports.mapConfig = mapConfig;
class HttpBase {
    constructor(options) {
        this.options = this.setDefaults(options);
        this.rootHttp = axios_1.default.create(Object.assign(Object.assign({}, options.requestConfig), { baseURL: this.options.baseURL }));
        this.http = axios_1.default.create(Object.assign(Object.assign({}, options.requestConfig), { baseURL: this.options.namespaceBaseURL }));
    }
    setDefaults(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const baseURLSet = ((_a = options.baseURL) !== null && _a !== void 0 ? _a : '') !== '' && ((_b = options.namespaceBaseURL) !== null && _b !== void 0 ? _b : '' !== '');
        if (!baseURLSet && ((_c = options.host) !== null && _c !== void 0 ? _c : '') === '') {
            throw new Error('Invalid options. Option host, or baseURL and namespaceBaseURL must be set.');
        }
        if (((_d = options.host) !== null && _d !== void 0 ? _d : '') === '' && ((_f = (_e = options.websocket) === null || _e === void 0 ? void 0 : _e.host) !== null && _f !== void 0 ? _f : '') === '') {
            throw new Error('Invalid options. Option host, or websocket.host must be set.');
        }
        return Object.assign(Object.assign({}, options), { baseURL: baseURLSet ? options.baseURL : `${options.host}/api/v1`, namespaceBaseURL: baseURLSet
                ? options.namespaceBaseURL
                : `${options.host}/api/v1/namespaces/${options.namespace}`, namespace: (_g = options.namespace) !== null && _g !== void 0 ? _g : 'default', websocket: Object.assign(Object.assign({}, options.websocket), { host: (_j = (_h = options.websocket) === null || _h === void 0 ? void 0 : _h.host) !== null && _j !== void 0 ? _j : options.host.replace('http', 'ws'), reconnectDelay: (_l = (_k = options.websocket) === null || _k === void 0 ? void 0 : _k.reconnectDelay) !== null && _l !== void 0 ? _l : 5000, heartbeatInterval: (_o = (_m = options.websocket) === null || _m === void 0 ? void 0 : _m.heartbeatInterval) !== null && _o !== void 0 ? _o : 30000 }) });
    }
    wrapError(response) {
        return __awaiter(this, void 0, void 0, function* () {
            return response.catch((err) => {
                var _a, _b, _c;
                if (axios_1.default.isAxiosError(err)) {
                    const errorMessage = (_c = (_b = (_a = err.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) !== null && _c !== void 0 ? _c : err.message;
                    const errorClass = (errorMessage === null || errorMessage === void 0 ? void 0 : errorMessage.includes('FF10430')) || (errorMessage === null || errorMessage === void 0 ? void 0 : errorMessage.includes('FF10431'))
                        ? interfaces_1.FireFlyIdempotencyError
                        : interfaces_1.FireFlyError;
                    const ffError = new errorClass(errorMessage, err, err.request.path);
                    if (this.errorHandler !== undefined) {
                        this.errorHandler(ffError);
                    }
                    throw ffError;
                }
                throw err;
            });
        });
    }
    getMany(url, params, options, root = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const http = root ? this.rootHttp : this.http;
            const response = yield this.wrapError(http.get(url, mapConfig(options, params)));
            return response.data;
        });
    }
    getOne(url, options, params, root = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const http = root ? this.rootHttp : this.http;
            const response = yield this.wrapError(http.get(url, Object.assign(Object.assign({}, mapConfig(options, params)), { validateStatus: (status) => status === 404 || isSuccess(status) })));
            return response.status === 404 ? undefined : response.data;
        });
    }
    createOne(url, data, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.wrapError(this.http.post(url, data, mapConfig(options)));
            return response.data;
        });
    }
    updateOne(url, data, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.wrapError(this.http.patch(url, data, mapConfig(options)));
            return response.data;
        });
    }
    replaceOne(url, data, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.wrapError(this.http.put(url, data, mapConfig(options)));
            return response.data;
        });
    }
    deleteOne(url, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.wrapError(this.http.delete(url, mapConfig(options)));
        });
    }
    onError(handler) {
        this.errorHandler = handler;
    }
}
exports.default = HttpBase;
