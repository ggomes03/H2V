"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const FormData = require("form-data");
const interfaces_1 = require("./interfaces");
const websocket_1 = require("./websocket");
const http_1 = require("./http");
class FireFly extends http_1.default {
    constructor() {
        super(...arguments);
        this.queue = Promise.resolve();
    }
    getStatus(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.http.get('/status', (0, http_1.mapConfig)(options));
            return response.data;
        });
    }
    getIdentities(filter, options) {
        return this.getMany('/identities', filter, options);
    }
    getIdentity(id, options) {
        return this.getOne(`/identities/${id}`, options);
    }
    createIdentity(identity, options) {
        return this.createOne(`/identities`, identity, options);
    }
    updateIdentity(id, update, options) {
        return this.updateOne(`/identities/${id}`, update, options);
    }
    getOrganizations(filter, options) {
        return this.getMany('/network/organizations', filter, options);
    }
    getOrganization(nameOrId, options) {
        return this.getOne(`/network/organizations/${nameOrId}`, options);
    }
    getNodes(filter, options) {
        return this.getMany('/network/nodes', filter, options);
    }
    getNode(nameOrId, options) {
        return this.getOne(`/network/nodes/${nameOrId}`, options);
    }
    getVerifiers(namespace, filter, options) {
        return namespace
            ? this.getMany(`/namespaces/${namespace}/verifiers`, filter, options, true)
            : this.getMany(`/verifiers`, filter, options);
    }
    getNamespace(name, options) {
        return this.getOne(`/namespaces/${name}`, undefined, options, true);
    }
    getNamespaces(options) {
        return this.getMany('/namespaces', undefined, options, true);
    }
    getDatatypes(filter, options) {
        return this.getMany('/datatypes', filter, options);
    }
    getDatatype(name, version, options) {
        return this.getOne(`/datatypes/${name}/${version}`, options);
    }
    createDatatype(req, options) {
        return this.createOne('/datatypes', req, options);
    }
    getSubscriptions(filter, options) {
        return this.getMany('/subscriptions', filter, options);
    }
    getSubscription(id, options) {
        return this.getOne(`/subscriptions/${id}`, options);
    }
    replaceSubscription(sub, options) {
        return this.replaceOne('/subscriptions', sub, options);
    }
    deleteSubscription(subId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deleteOne(`/subscriptions/${subId}`, options);
        });
    }
    getData(id, options) {
        return this.getOne(`/data/${id}`, options);
    }
    findData(filter, options) {
        return this.getMany(`/data`, filter, options);
    }
    getDataBlob(id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.wrapError(this.http.get(`/data/${id}/blob`, Object.assign(Object.assign({}, (0, http_1.mapConfig)(options)), { responseType: 'stream' })));
            return response.data;
        });
    }
    uploadData(data, options) {
        return this.createOne('/data', data, options);
    }
    publishData(id, options) {
        return this.createOne(`/data/${id}/value/publish`, {}, options);
    }
    uploadDataBlob(blob, blobOptions, dataOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            dataOptions = Object.assign(Object.assign({}, interfaces_1.FireFlyDataBlobRequestDefaults), dataOptions);
            const formData = new FormData();
            for (const key in dataOptions) {
                const val = dataOptions[key];
                if (val !== undefined) {
                    formData.append(key, val);
                }
            }
            formData.append('file', blob, blobOptions);
            const requestOptions = (0, http_1.mapConfig)(options);
            const response = yield this.wrapError(this.http.post('/data', formData, Object.assign(Object.assign({}, requestOptions), { headers: Object.assign(Object.assign(Object.assign({}, requestOptions.headers), formData.getHeaders()), { 'Content-Length': formData.getLengthSync() }) })));
            return response.data;
        });
    }
    publishDataBlob(id, options) {
        return this.createOne(`/data/${id}/blob/publish`, {}, options);
    }
    deleteData(id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deleteOne(`/data/${id}`, options);
        });
    }
    getBatches(filter, options) {
        return this.getMany(`/batches`, filter, options);
    }
    getMessages(filter, options) {
        return this.getMany(`/messages`, filter, options);
    }
    getMessage(id, options) {
        return this.getOne(`/messages/${id}`, options);
    }
    sendBroadcast(message, options) {
        return this.createOne('/messages/broadcast', message, options);
    }
    sendPrivateMessage(message, options) {
        const url = (options === null || options === void 0 ? void 0 : options.requestReply) ? '/messages/requestreply' : '/messages/private';
        return this.createOne(url, message, options);
    }
    getGroup(hash, options) {
        return this.getOne(`/groups/${hash}`, options);
    }
    createTokenPool(pool, options) {
        return this.createOne('/tokens/pools', pool, options);
    }
    getTokenPools(filter, options) {
        return this.getMany(`/tokens/pools`, filter, options);
    }
    getTokenPool(nameOrId, options) {
        return this.getOne(`/tokens/pools/${nameOrId}`, options);
    }
    deleteTokenPool(nameOrId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deleteOne(`/tokens/pools/${nameOrId}`, options);
        });
    }
    mintTokens(transfer, options) {
        return this.createOne('/tokens/mint', transfer, options);
    }
    transferTokens(transfer, options) {
        return this.createOne('/tokens/transfers', transfer, options);
    }
    approveTokens(approval, options) {
        return this.createOne('/tokens/approvals', approval, options);
    }
    getTokenApprovals(filter, options) {
        return this.getMany(`/tokens/approvals`, filter, options);
    }
    burnTokens(transfer, options) {
        return this.createOne('/tokens/burn', transfer, options);
    }
    resolveVerifier(input, namespace) {
        return this.createOne(`/verifiers/resolve`, input);
    }
    getTokenTransfers(filter, options) {
        return this.getMany(`/tokens/transfers`, filter, options);
    }
    getTokenTransfer(id, options) {
        return this.getOne(`/tokens/transfers/${id}`, options);
    }
    getTokenBalances(filter, options) {
        return this.getMany('/tokens/balances', filter, options);
    }
    deployContract(request, options) {
        return this.createOne('/contracts/deploy', request, options);
    }
    generateContractInterface(request, options) {
        return this.createOne('/contracts/interfaces/generate', request, options);
    }
    createContractInterface(ffi, options) {
        return this.createOne('/contracts/interfaces', ffi, options);
    }
    getContractInterfaces(filter, options) {
        return this.getMany('/contracts/interfaces', filter, options);
    }
    getContractInterface(id, fetchchildren, options) {
        return this.getOne(`/contracts/interfaces/${id}`, options, {
            fetchchildren,
        });
    }
    createContractAPI(api, options) {
        return this.createOne('/apis', api, options);
    }
    getContractAPIs(filter, options) {
        return this.getMany('/apis', filter, options);
    }
    getContractAPI(name, options) {
        return this.getOne(`/apis/${name}`, options);
    }
    invokeContract(request, options) {
        return this.createOne('/contracts/invoke', request, options);
    }
    queryContract(request, options) {
        return this.createOne('/contracts/query', request, options);
    }
    invokeContractAPI(apiName, methodPath, request, options) {
        return this.createOne(`/apis/${apiName}/invoke/${methodPath}`, request, options);
    }
    queryContractAPI(apiName, methodPath, request, options) {
        return this.createOne(`/apis/${apiName}/query/${methodPath}`, request, options);
    }
    createContractListener(listener, options) {
        return this.createOne('/contracts/listeners', listener, options);
    }
    getContractListeners(filter, options) {
        return this.getMany('/contracts/listeners', filter, options);
    }
    deleteContractListener(id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deleteOne(`/contracts/listeners/${id}`, options);
        });
    }
    getContractAPIListeners(apiName, eventPath, options) {
        return this.getMany(`/apis/${apiName}/listeners/${eventPath}`, {}, options);
    }
    createContractAPIListener(apiName, eventPath, listener, options) {
        return this.createOne(`/apis/${apiName}/listeners/${eventPath}`, listener, options);
    }
    getOperations(filter, options) {
        return this.getMany('/operations', filter, options);
    }
    getOperation(id, options) {
        const params = { fetchstatus: options === null || options === void 0 ? void 0 : options.fetchstatus };
        return this.getOne(`/operations/${id}`, options, params);
    }
    retryOperation(id, options) {
        return this.createOne(`/operations/${id}/retry`, {}, options);
    }
    getTransactions(filter, options) {
        return this.getMany('/transactions', filter, options);
    }
    getTransaction(id, options) {
        return this.getOne(`/transactions/${id}`, options);
    }
    getBlockchainEvents(filter, options) {
        return this.getMany('/blockchainevents', filter, options);
    }
    getBlockchainEvent(id, options) {
        return this.getOne(`/blockchainevents/${id}`, options);
    }
    listen(subscriptions, callback, socketOptions, fireflySocketOptions) {
        if (typeof fireflySocketOptions === 'function') {
            // Legacy compatibility (afterConnect callback passed as 4th arg)
            fireflySocketOptions = {
                afterConnect: fireflySocketOptions,
            };
        }
        const options = Object.assign(Object.assign({ host: this.options.websocket.host, namespace: this.options.namespace, username: this.options.username, password: this.options.password, reconnectDelay: this.options.websocket.reconnectDelay, heartbeatInterval: this.options.websocket.heartbeatInterval, autoack: false }, fireflySocketOptions), { socketOptions, subscriptions: [] });
        const handler = (socket, event) => {
            this.queue = this.queue.finally(() => callback(socket, event));
            if (!options.noack) {
                this.queue.then(() => {
                    socket.ack(event);
                });
            }
        };
        if (Array.isArray(subscriptions)) {
            options.subscriptions = subscriptions;
        }
        else if (typeof subscriptions === 'string') {
            options.subscriptions = [subscriptions];
        }
        else {
            options.ephemeral = Object.assign(Object.assign({}, subscriptions), { namespace: this.options.namespace });
        }
        return new websocket_1.FireFlyWebSocket(options, handler);
    }
}
exports.default = FireFly;
